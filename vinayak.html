
<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Algorithms & Nature — Summary</title>
  <style>
    :root{--accent:#2563eb;--muted:#6b7280;--bg:#0f172a;--card:#0b1220}
    body{font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;line-height:1.6;margin:0;background:#f8fafc;color:#0b1220}
    header{background:linear-gradient(90deg,#eef2ff,#f0fdf4);padding:28px 20px;border-bottom:1px solid rgba(11,18,32,0.04)}
    .container{max-width:980px;margin:24px auto;padding:0 18px}
    h1{margin:0 0 6px;font-size:1.6rem}
    p.lead{margin:0;color:var(--muted)}
    nav.toc{margin-top:18px;display:flex;flex-wrap:wrap;gap:8px}
    nav.toc a{background:#fff;border:1px solid rgba(11,18,32,0.06);padding:6px 10px;border-radius:10px;text-decoration:none;color:var(--accent);font-size:0.9rem}
    section.card{background:#fff;padding:18px;margin:18px 0;border-radius:10px;box-shadow:0 6px 20px rgba(12,22,45,0.04)}
    section.card h2{margin-top:0}
    .muted{color:var(--muted)}
    pre.code{background:#0b1220;color:#e6eef8;padding:12px;border-radius:8px;overflow:auto}
    /* Order-of-growth chart */
    .o-chart{display:grid;grid-template-columns:160px 1fr;gap:10px;align-items:center}
    .o-label{font-family:monospace}
    .bar{height:18px;border-radius:8px;background:linear-gradient(90deg,var(--accent),#7c3aed);box-shadow:inset 0 -4px 0 rgba(255,255,255,0.03)}
    .bar.s1{width:4%}
    .bar.slog{width:8%}
    .bar.sn{width:30%}
    .bar.snlog{width:45%}
    .bar.sq{width:70%}
    .bar.s2n{width:92%}
    .bar.snf{width:100%}
    footer{padding:18px;text-align:center;color:var(--muted);font-size:0.9rem}
    @media (max-width:600px){.o-chart{grid-template-columns:1fr}} 
  </style><style>
/* --- BODY --- */
body {
    margin: 0;
    padding: 0;
    font-family: 'Space Grotesk', sans-serif;
    background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
    color: #fff;
    min-height: 100vh;
}

/* --- CONTAINER --- */
.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 40px 20px;
}

/* --- NAVBAR --- */
header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px 30px;
    background: linear-gradient(90deg, #ff512f, #dd2476);
    border-radius: 15px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.5);
    margin-bottom: 50px;
}

header .logo {
    display: flex;
    align-items: center;
    gap: 10px;
    font-family: 'Pacifico', cursive;
    font-size: 1.8rem;
    font-weight: 700;
    color: #fff;
}

header .logo img {
    width: 40px;
    height: 40px;
    border-radius: 50%;
}

header .navbar h1 {
    color: #fff;
    font-size: 1.5rem;
    font-weight: 700;
    margin-right: 30px;
}

header .navbar ul {
    list-style: none;
    display: flex;
    gap: 20px;
    margin: 0;
    padding: 0;
}

header .navbar ul li a {
    color: #fff;
    text-decoration: none;
    font-weight: 600;
    padding: 8px 15px;
    border-radius: 8px;
    transition: all 0.3s ease;
}

header .navbar ul li a:hover {
    background: rgba(255,255,255,0.2);
    color: #ffdd59;
    transform: scale(1.05);
}

/* --- GLASS PANELS --- */
.glass-panel {
    background: rgba(255,255,255,0.05);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 25px;
    padding: 30px 40px;
    margin-bottom: 30px;
    border: 1px solid rgba(255,255,255,0.2);
    transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

.glass-panel:hover {
    transform: translateY(-10px) scale(1.02);
    box-shadow: 0 20px 50px rgba(255,140,0,0.5);
}

/* --- INTRO CARD --- */
.intro-card p {
    font-size: 1.6rem;
    line-height: 1.8;
    text-align: center;
    animation: fadeInZoom 1s ease forwards;
}

@keyframes fadeInZoom {
    0% { opacity: 0; transform: scale(0.8); }
    100% { opacity: 1; transform: scale(1); }
}

/* --- GRADIENT HEADINGS --- */
h2, h3 {
    background: linear-gradient(90deg, #ff512f, #dd2476, #f0ff00);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
}

/* --- TABLE --- */
.styled-table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
}

.styled-table caption {
    caption-side: top;
    font-size: 1.3rem;
    margin-bottom: 10px;
}

.styled-table th, .styled-table td {
    border: 1px solid #fff;
    padding: 12px 15px;
    text-align: left;
}

.styled-table th {
    background: rgba(255,140,0,0.2);
}

/* --- CARDS GRID --- */
.course-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 25px;
}

/* --- CARD STYLING --- */
.qa-card, .card {
    background: rgba(255,140,0,0.05);
    padding: 25px;
    border-radius: 25px;
    transition: all 0.5s ease;
    position: relative;
    overflow: hidden;
    cursor: pointer;
}

.qa-card:hover, .card:hover {
    animation: bounce 0.6s;
    transform: scale(1.04);
    box-shadow: 0 25px 60px rgba(255,140,0,0.6);
}

@keyframes bounce {
    0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
    40% { transform: translateY(-15px); }
    60% { transform: translateY(-8px); }
}

/* --- BUTTONS --- */
a.btn {
    display: inline-block;
    margin-top: 12px;
    padding: 10px 25px;
    background: rgba(255,140,0,0.2);
    color: #fff;
    text-decoration: none;
    border-radius: 30px;
    font-weight: 600;
    transition: all 0.3s ease;
}

a.btn:hover {
    background: #ff8c00;
    color: #000;
    box-shadow: 0 10px 20px rgba(255,140,0,0.5);
}

/* --- SHIMMER EFFECT --- */
.qa-card::before, .card::before {
    content: '';
    position: absolute;
    top: 0;
    left: -75%;
    width: 50%;
    height: 100%;
    background: linear-gradient(120deg, transparent, rgba(255,255,255,0.2), transparent);
    transform: skewX(-25deg);
}

.qa-card:hover::before, .card:hover::before {
    animation: shimmer 1s forwards;
}

@keyframes shimmer {
    0% { left: -75%; }
    100% { left: 125%; }
}

/* --- SCROLL ANIMATION --- */
.hidden {
    opacity: 0;
    transform: translateY(50px);
    transition: all 0.8s ease-out;
}

.show {
    opacity: 1;
    transform: translateY(0);
}

/* --- FOOTER --- */
footer {
    text-align: center;
    padding: 20px;
    opacity: 0.8;
    margin-top: 50px;
    font-size: 0.9rem;
    color: #ffdd59;
}
</style></head>
<body>
  <header>
    <div class="container">
      <h1>Algorithms & Nature — Concise Summary</h1>
      <p class="lead">A clear, structured HTML summary covering computational patterns observed in nature, complexity, design principles, data structures, and algorithm techniques.</p>
      <nav class="toc" aria-label="Table of contents">
        <a href="#q1">1. Nature & Computational Patterns</a>
        <a href="#q2">2. Space & Time Efficiency</a>
        <a href="#q3">3. Design Principles</a>
        <a href="#q4">4. Hierarchical Data & Trees</a>
        <a href="#q5">5. Array Query Algorithms</a>
        <a href="#q6">6. Trees vs Graphs</a>
        <a href="#q7">7. Sorting & Searching</a>
        <a href="#q8">8. Graph Algorithms</a>
        <a href="#q9">9. Design Techniques Overview</a>
      </nav>
    </div>
  </header>  <main class="container"><section id="q1" class="card">
  <h2>1. What kinds of problems do we observe in nature? (iteration, recursion, backtracking)</h2>
  <p>Nature naturally mirrors computational patterns:</p>
  <ul>
    <li><strong>Iteration:</strong> Seasonal cycles (spring → summer → monsoon → winter) repeat—an iterative process that continues until interrupted.</li>
    <li><strong>Recursion:</strong> Structural repetition at multiple scales (e.g., patterns on millipedes or branching leaf structures) where a form contains smaller copies of itself.</li>
    <li><strong>Backtracking:</strong> Exploratory behaviors—animals navigating burrows or foraging paths—where failed routes are abandoned and earlier decision points are revisited to try alternatives.</li>
  </ul>
</section>

<section id="q2" class="card">
  <h2>2. What is space and time efficiency? Why are they important?</h2>
  <p>Space efficiency measures extra memory an algorithm uses. Time efficiency measures how long it takes to run. Both affect performance, cost, and scalability when handling large inputs.</p>
  <h3>Major complexity classes</h3>
  <ul>
    <li>O(1) — Constant</li>
    <li>O(log n) — Logarithmic</li>
    <li>O(n) — Linear</li>
    <li>O(n log n) — Linearithmic</li>
    <li>O(n²) — Quadratic</li>
    <li>O(2ⁿ) — Exponential</li>
    <li>O(n!) — Factorial</li>
  </ul>

  <h3>Order of Growth Chart</h3>
  <div class="o-chart">
    <div class="o-label">O(1)</div><div class="bar s1"></div>
    <div class="o-label">O(log n)</div><div class="bar slog"></div>
    <div class="o-label">O(n)</div><div class="bar sn"></div>
    <div class="o-label">O(n log n)</div><div class="bar snlog"></div>
    <div class="o-label">O(n²)</div><div class="bar sq"></div>
    <div class="o-label">O(2ⁿ)</div><div class="bar s2n"></div>
    <div class="o-label">O(n!)</div><div class="bar snf"></div>
  </div>

  <p class="muted">Note: shorter bars = better scalability. O(1) and O(log n) are most efficient for large inputs; exponential and factorial grow infeasibly fast.</p>
</section>

<section id="q3" class="card">
  <h2>3. Key takeaways from the design principles (Chapter 2)</h2>
  <ul>
    <li>Tie algorithm intuition to strong design philosophies to make complex ideas approachable.</li>
    <li>Use the BFS vs DFS analogy: bold breadth-first exploration versus cautious depth-first probing.</li>
    <li>Prefix & suffix thinking underlies pattern-matching algorithms such as KMP and Boyer–Moore.</li>
    <li>Balancing techniques (rotations) are central to stable tree structures like AVL and red-black trees.</li>
  </ul>
</section>

<section id="q4" class="card">
  <h2>4. Hierarchical data and how tree structures optimize solutions</h2>
  <p>Trees model hierarchical relationships efficiently. Key points:</p>
  <ul>
    <li><strong>Binary Trees:</strong> Simple hierarchical storage; susceptible to skewness.</li>
    <li><strong>AVL Trees:</strong> Maintain strict balance via rotations for guaranteed O(log n) operations.</li>
    <li><strong>Red-Black Trees:</strong> Easier balancing rules with good practical performance.</li>
    <li><strong>2–3 Trees:</strong> Store multiple keys per node to preserve balanced height.</li>
    <li><strong>Heaps:</strong> Ideal for priority operations (extract-max/extract-min).</li>
    <li><strong>Tries:</strong> Excellent for prefix searches, autocomplete, and dictionary operations.</li>
  </ul>
</section>

<section id="q5" class="card">
  <h2>5. Need for array query algorithms and their implications</h2>
  <p>Range-query techniques let systems extract statistics quickly from subarray ranges—valuable in e-commerce filters, financial trend analysis, and analytics dashboards.</p>
  <ul>
    <li><strong>Fenwick Trees (BIT):</strong> Compact, efficient point-update and prefix-sum queries using bit manipulation.</li>
    <li><strong>Segment Trees:</strong> Support range updates and range queries with flexible combination functions.</li>
    <li><strong>Lookup Tables / Precomputation:</strong> Trade memory for near-instant queries when input space is limited.</li>
  </ul>
</section>

<section id="q6" class="card">
  <h2>6. Difference between trees and graphs, their traversals, and applications</h2>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
    <div>
      <h4>Trees</h4>
      <ul>
        <li>Connected, acyclic, with a root</li>
        <li>Exactly n−1 edges for n nodes</li>
        <li>No cycles</li>
      </ul>
    </div>
    <div>
      <h4>Graphs</h4>
      <ul>
        <li>May be connected/disconnected</li>
        <li>Can contain cycles</li>
        <li>No required root; edges arbitrary</li>
      </ul>
    </div>
  </div>

  <h4>Traversals</h4>
  <p><strong>Tree:</strong> Pre-order (Root→Left→Right), In-order (Left→Root→Right), Post-order (Left→Right→Root).</p>
  <p><strong>Graph:</strong> DFS for deep exploration (mazes, path finding), BFS for level-wise search (shortest unweighted paths, network routing).</p>
</section>

<section id="q7" class="card">
  <h2>7. Sorting and searching algorithms: techniques and real-world relevance</h2>
  <ul>
    <li><strong>Bubble / Insertion / Selection:</strong> Educational and fine for small inputs.</li>
    <li><strong>Merge Sort:</strong> Stable divide & conquer with O(n log n) worst-case.</li>
    <li><strong>Quick Sort:</strong> Fast in practice; average O(n log n), but worst-case O(n²) without good pivoting.</li>
    <li><strong>Searching:</strong> Linear search for unsorted lists; binary search for sorted lists (O(log n)).</li>
  </ul>
  <p class="muted">Applications: product listing, database indexing, ranking, file search, and information retrieval systems.</p>
</section>

<section id="q8" class="card">
  <h2>8. Importance of graph algorithms—spanning trees and shortest paths</h2>
  <p>Spanning trees (e.g., MST via Kruskal/Prim) minimise connection cost—useful for network design. Shortest-path algorithms (Dijkstra, Bellman-Ford, Floyd–Warshall) find optimal routes in weighted networks—critical for navigation, routing, and logistics.</p>
</section>

<section id="q9" class="card">
  <h2>9. Overview of algorithm design techniques studied</h2>
  <ul>
    <li><strong>Backtracking:</strong> Systematic exploration with pruning (N-Queens, constraint satisfaction).</li>
    <li><strong>Divide & Conquer:</strong> Break problems into subproblems and combine (Merge Sort, Quick Sort).</li>
    <li><strong>Shortest Path Algorithms:</strong> Dijkstra (non-negative weights), Floyd–Warshall (all pairs).</li>
    <li><strong>Graph Traversals:</strong> BFS/DFS to structure exploration and search.</li>
  </ul>
</section>

<footer>
  <p>Generated summary • Use this HTML to embed in a GitHub repo or print as a quick reference.</p>
</footer>

  </main></body>
                                             </html>
