<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Coastal Smart City – Integrated Business Models</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;600;700&family=Pacifico&display=swap" rel="stylesheet">

  <!-- Prism.js dark theme + core + autoloader -->
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
  <script defer
          src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
  <script defer
          src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"
          data-autoloader-path="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/"></script>

  <style>
    body{
      margin:0;padding:0;
      font-family:'Space Grotesk',sans-serif;
      background:linear-gradient(135deg,#0f0c29,#302b63,#24243e);
      color:#fff;min-height:100vh;
    }
    .container{max-width:1200px;margin:0 auto;padding:40px 20px;}
    header{
      display:flex;justify-content:space-between;align-items:center;
      padding:15px 30px;margin-bottom:40px;
      background:linear-gradient(90deg,#ff512f,#dd2476);
      border-radius:15px;box-shadow:0 5px 20px rgba(0,0,0,.5);
    }
    .logo{
      display:flex;align-items:center;gap:10px;
      font-family:'Pacifico',cursive;font-size:1.8rem;font-weight:700;color:#fff;
    }
    .logo img{width:40px;height:40px;border-radius:50%;}
    .navbar h1{margin:0 0 6px 0;font-size:1.45rem;}
    .navbar ul{margin:0;padding:0;list-style:none;display:flex;gap:16px;flex-wrap:wrap;}
    .navbar a{
      color:#fff;text-decoration:none;font-weight:600;
      padding:7px 14px;border-radius:8px;transition:.3s;
    }
    .navbar a:hover,.navbar a.active{
      background:rgba(255,255,255,.2);color:#ffdd59;transform:scale(1.05);
    }

    .glass-panel{
      background:rgba(255,255,255,.05);
      backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);
      border-radius:25px;padding:25px 30px;margin-bottom:20px;
      border:1px solid rgba(255,255,255,.2);
      transition:.5s cubic-bezier(.175,.885,.32,1.275);
    }
    .glass-panel:hover{
      transform:translateY(-6px) scale(1.01);
      box-shadow:0 18px 40px rgba(255,140,0,.45);
    }
    .intro p{
      font-size:1.4rem;line-height:1.7;text-align:center;margin:0;
    }

    h2,h3{
      margin-top:0;
      background:linear-gradient(90deg,#ff512f,#dd2476,#f0ff00);
      -webkit-background-clip:text;-webkit-text-fill-color:transparent;
    }
    .course-container{
      display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
      gap:18px;
    }
    .card,.qa-card{
      background:rgba(255,140,0,.06);
      padding:16px 18px;border-radius:18px;
      transition:.4s;position:relative;overflow:hidden;
      font-size:.95rem;
    }
    .card:hover,.qa-card:hover{
      transform:scale(1.02);
      box-shadow:0 22px 50px rgba(255,140,0,.6);
    }
    a.btn{
      display:inline-block;margin-top:10px;
      padding:8px 20px;border-radius:22px;
      background:rgba(255,140,0,.2);color:#fff;
      font-weight:600;text-decoration:none;cursor:pointer;transition:.3s;
    }
    a.btn:hover{
      background:#ff8c00;color:#000;
      box-shadow:0 10px 20px rgba(255,140,0,.5);
    }
    pre{
      background:rgba(0,0,0,.4);
      padding:12px;border-radius:12px;
      overflow:auto;font-size:.82rem;
    }
    .hidden{display:none;}
    footer{
      text-align:center;padding:18px 10px;margin-top:30px;
      font-size:.88rem;color:#ffdd59;opacity:.9;
    }
  </style>
</head>
<body>
<div class="container">
  <header>
    <div class="logo">
      <img src="https://via.placeholder.com/40" alt="Logo">
      Coastal Smart City
    </div>
    <nav class="navbar">
      <div>
        <h1>Integrated Algorithmic Businesses</h1>
        <ul>
          <li><a href="#" data-business="fuel" class="active">Fuel Station</a></li>
          <li><a href="#" data-business="apmc">APMC</a></li>
          <li><a href="#" data-business="traffic">Traffic</a></li>
          <li><a href="#" data-business="construction">Construction</a></li>
        </ul>
      </div>
    </nav>
  </header>

  <section class="glass-panel intro">
    <p>
      1300 sq km coastal smart city (~18 million people) with four core businesses:
      Fuel Station Management, APMC Management, Traffic Management, and Construction Contracting,
      all powered by greedy + dynamic programming and graph algorithms.
    </p>
  </section>

  <!-- FUEL BUSINESS VIEW -->
  <div class="business-view" id="view-fuel">
    <section class="glass-panel">
      <h2>Fuel Station Management – Overview</h2>
      <p>
        Plan and operate fuel + EV stations across coastal, urban, and highway zones, reducing detours,
        queues, and emissions while maximizing utilization and service coverage.
      </p>
    </section>

    <section class="glass-panel">
      <h2>Logic & Algorithms</h2>
      <div class="course-container">
        <div class="qa-card">
          <h3>Technique & Principle</h3>
          <p>
            Greedy assignment of demand points to nearest feasible stations plus DP for multi-day
            cost/coverage planning. Core principles: partitioning city into zones and shortest path trees
            for travel time estimates.
          </p>
        </div>
        <div class="qa-card">
          <h3>Graphs & Data</h3>
          <p>
            Nodes: demand clusters and candidate stations; edges: road segments with distance/time.
            Sorting (Quick/Merge) orders stations by capacity; Rabin–Karp/linear search can scan logs
            for anomalies or configuration patterns.
          </p>
        </div>
      </div>
    </section>

    <section class="glass-panel">
      <h2>C++ Core & Efficiency</h2>
      <p><strong>Efficiency:</strong> Greedy assignment is O(S·D), sorting stations is O(S log S), and DP over a short horizon is O(H) per station.</p>
      <pre><code class="language-cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;

struct DemandPoint { int id; double x,y,demand; };
struct Station { int id; double x,y,capacity; };

double dist2d(double x1,double y1,double x2,double y2){
  double dx=x1-x2,dy=y1-y2; return sqrt(dx*dx+dy*dy);
}

void greedyAssignFuel(vector&lt;DemandPoint&gt;& dem, vector&lt;Station&gt;& st){
  for(auto &d:dem){
    int bestId=-1; double bestCost=1e18;
    for(auto &s:st){
      if(s.capacity&lt;d.demand) continue;
      double c=dist2d(d.x,d.y,s.x,s.y);
      if(c&lt;bestCost){bestCost=c;bestId=s.id;}
    }
    if(bestId!=-1)
      cout &lt;&lt; "Fuel demand " &lt;&lt; d.id &lt;&lt; " -> station " &lt;&lt; bestId
          &lt;&lt; " (" &lt;&lt; bestCost &lt;&lt; " km)\n";
    else
      cout &lt;&lt; "No feasible station for demand " &lt;&lt; d.id &lt;&lt; "\n";
  }
}

map&lt;pair&lt;int,int&gt;,double&gt; memoFuel;
double fuelCostDP(int sid,int day,int H,double base){
  if(day&gt;=H) return 0;
  auto key=make_pair(sid,day);
  if(memoFuel.count(key)) return memoFuel[key];
  double today=base*(1.0+0.03*day);
  double rest=fuelCostDP(sid,day+1,H,base);
  return memoFuel[key]=today+rest;
}

int main(){
  vector&lt;DemandPoint&gt; dem={{1,2,3,500},{2,10,8,700}};
  vector&lt;Station&gt; st={{1,1,2,1000},{2,9,9,800}};
  sort(st.begin(),st.end(),[](auto &a,auto &b){return a.capacity&gt;b.capacity;});
  greedyAssignFuel(dem,st);
  cout &lt;&lt; "Fuel 7-day cost s1: " &lt;&lt; fuelCostDP(1,0,7,1.0) &lt;&lt; "\n";
  return 0;
}
      </code></pre>
    </section>
  </div>

  <!-- APMC BUSINESS VIEW -->
  <div class="business-view hidden" id="view-apmc">
    <section class="glass-panel">
      <h2>APMC Management – Overview</h2>
      <p>
        Digitally manage mandis, auctions, logistics, and payments, linking farmers, traders, and export
        terminals, improving price discovery and reducing waste.
      </p>
    </section>

    <section class="glass-panel">
      <h2>Logic & Algorithms</h2>
      <div class="course-container">
        <div class="qa-card">
          <h3>Technique & Principle</h3>
          <p>
            Greedy auction clearing (highest price first) over merge-sorted bids, plus DP to decide
            sell-now vs store-and-sell-later. Principles: partitioning by commodity/grade and hierarchical
            market data (village → mandi → export).
          </p>
        </div>
        <div class="qa-card">
          <h3>Data & Searching</h3>
          <p>
            Merge Sort for stable bid lists, Rabin–Karp for scanning logs for collusion or repeated
            patterns in trader IDs; brute force for small searches.
          </p>
        </div>
      </div>
    </section>

    <section class="glass-panel">
      <h2>C++ Core & Efficiency</h2>
      <p><strong>Efficiency:</strong> Bids sorted in O(B log B), clearing in O(B), and DP per lot in O(T).</p>
      <pre><code class="language-cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Lot{int id;string commodity;double qty,basePrice;int perishDays;};
struct Bid{int lotId,traderId;double price,qty;};

bool cmpBid(const Bid&a,const Bid&b){
  if(a.price!=b.price) return a.price&gt;b.price;
  return a.traderId&lt;b.traderId;
}
void mergeVec(vector&lt;Bid&gt;&a,int l,int m,int r){
  int n1=m-l+1,n2=r-m; vector&lt;Bid&gt;L(n1),R(n2);
  for(int i=0;i&lt;n1;i++)L[i]=a[l+i];
  for(int j=0;j&lt;n2;j++)R[j]=a[m+1+j];
  int i=0,j=0,k=l;
  while(i&lt;n1 && j&lt;n2) a[k++]=cmpBid(L[i],R[j])?L[i++]:R[j++];
  while(i&lt;n1)a[k++]=L[i++]; while(j&lt;n2)a[k++]=R[j++];
}
void mergeSort(vector&lt;Bid&gt;&a,int l,int r){
  if(l&gt;=r)return; int m=l+(r-l)/2;
  mergeSort(a,l,m); mergeSort(a,m+1,r); mergeVec(a,l,m,r);
}
double clearAuctionGreedy(const Lot &lot,const vector&lt;Bid&gt;&b){
  double rem=lot.qty,rev=0;
  for(auto &x:b){
    if(x.lotId!=lot.id) continue;
    if(x.price&lt;lot.basePrice) continue;
    if(rem&lt;=0) break;
    double t=min(rem,x.qty); rev+=t*x.price; rem-=t;
  }
  return rev;
}
map&lt;pair&lt;int,int&gt;,double&gt; memoAPMC;
double bestRevenueDP(const Lot &lot,int day,int maxDay,const vector&lt;double&gt;&f){
  if(day&gt;=maxDay || lot.perishDays-day&lt;=0) return 0;
  auto key=make_pair(lot.id,day);
  if(memoAPMC.count(key)) return memoAPMC[key];
  double sellNow=lot.qty*f[day];
  double storedQty=lot.qty*0.98;
  double waitVal=storedQty*f[day+1];
  return memoAPMC[key]=max(sellNow,waitVal);
}

int main(){
  Lot tomato{1,"Tomato",1000,12.0,3};
  vector&lt;Bid&gt; bids={{1,201,13.5,400},{1,202,13.0,300},{1,203,12.5,600}};
  mergeSort(bids,0,(int)bids.size()-1);
  cout &lt;&lt; "APMC greedy revenue: " &lt;&lt; clearAuctionGreedy(tomato,bids) &lt;&lt; "\n";
  vector&lt;double&gt; f={12.0,13.0,11.0};
  cout &lt;&lt; "APMC DP best revenue: " &lt;&lt; bestRevenueDP(tomato,0,2,f) &lt;&lt; "\n";
  return 0;
}
      </code></pre>
    </section>
  </div>

  <!-- TRAFFIC BUSINESS VIEW -->
  <div class="business-view hidden" id="view-traffic">
    <section class="glass-panel">
      <h2>Traffic Management – Overview</h2>
      <p>
        Manage signals and routing on the city’s road network to reduce congestion, improve average speeds,
        and support safe, reliable public transport.
      </p>
    </section>

    <section class="glass-panel">
      <h2>Logic & Algorithms</h2>
      <div class="course-container">
        <div class="qa-card">
          <h3>Technique & Principle</h3>
          <p>
            Dijkstra shortest paths for route times, greedy signal control choosing lanes with largest queues,
            and DP over time slots for corridor delay estimation.
          </p>
        </div>
        <div class="qa-card">
          <h3>Data & Efficiency</h3>
          <p>
            Graph nodes are intersections, edges are road segments. Heap-based priority queue gives
            O((V+E) log V) routing; greedy per intersection is O(d) (d = approaches).
          </p>
        </div>
      </div>
    </section>

    <section class="glass-panel">
      <h2>C++ Core & Efficiency</h2>
      <p><strong>Efficiency:</strong> Shortest paths are O((V+E) log V); greedy phase selection is O(d); DP corridor cost is O(T).</p>
      <pre><code class="language-cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Edge{int to;double baseTime,congestion;};
using Graph=vector&lt;vector&lt;Edge&gt;&gt;;

vector&lt;double&gt; shortestPath(const Graph &g,int src){
  int n=g.size();const double INF=1e18;
  vector&lt;double&gt; dist(n,INF);dist[src]=0;
  using P=pair&lt;double,int&gt;;
  priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt;&gt; pq;
  pq.push({0,src});
  while(!pq.empty()){
    auto [d,u]=pq.top();pq.pop();
    if(d&gt;dist[u])continue;
    for(auto &e:g[u]){
      double w=e.baseTime*e.congestion;
      if(dist[u]+w&lt;dist[e.to]){
        dist[e.to]=dist[u]+w;pq.push({dist[e.to],e.to});
      }
    }
  }
  return dist;
}
struct IntersectionState{int id;vector&lt;int&gt; q;};
int chooseGreenPhaseGreedy(const IntersectionState&st){
  int best=0,bq=-1;
  for(int i=0;i&lt;(int)st.q.size();i++)
    if(st.q[i]&gt;bq){bq=st.q[i];best=i;}
  return best;
}
map&lt;pair&lt;int,int&gt;,double&gt; memoTraffic;
double corridorCostDP(int cid,int slot,int H,const vector&lt;double&gt;&d){
  if(slot&gt;=H)return 0;
  auto key=make_pair(cid,slot);
  if(memoTraffic.count(key))return memoTraffic[key];
  return memoTraffic[key]=d[slot]+corridorCostDP(cid,slot+1,H,d);
}
int main(){
  Graph g(4);
  g[0].push_back({1,10.0,1.2});
  g[1].push_back({2,8.0,1.5});
  g[2].push_back({3,6.0,1.1});
  auto dist=shortestPath(g,0);
  cout &lt;&lt; "Traffic 0->3: " &lt;&lt; dist[3] &lt;&lt; "\n";
  IntersectionState st{1,{10,25,5,12}};
  cout &lt;&lt; "Chosen phase: " &lt;&lt; chooseGreenPhaseGreedy(st) &lt;&lt; "\n";
  vector&lt;double&gt; d={100,120,130,110};
  cout &lt;&lt; "Corridor delay: " &lt;&lt; corridorCostDP(0,0,(int)d.size(),d) &lt;&lt; "\n";
  return 0;
}
      </code></pre>
    </section>
  </div>

  <!-- CONSTRUCTION BUSINESS VIEW -->
  <div class="business-view hidden" id="view-construction">
    <section class="glass-panel">
      <h2>Construction Contracting – Overview</h2>
      <p>
        Plan and execute housing, bridges, and coastal works with optimized schedules, logistics,
        and risk-aware budgeting for resilient infrastructure.
      </p>
    </section>

    <section class="glass-panel">
      <h2>Logic & Algorithms</h2>
      <div class="course-container">
        <div class="qa-card">
          <h3>Technique & Principle</h3>
          <p>
            Greedy scheduling by deadline and penalty, plus DP over days for cost accumulation under
            risk (e.g., monsoon). Principles: decomposition of projects into tasks, logistics graph
            shortest paths between depots and sites.
          </p>
        </div>
        <div class="qa-card">
          <h3>Data & Runtime</h3>
          <p>
            Sorting tasks is O(N log N); shortest path on logistics graph is O((V+E) log V); DP per project
            over horizon H is O(H).
          </p>
        </div>
      </div>
    </section>

    <section class="glass-panel">
      <h2>C++ Core & Efficiency</h2>
      <p><strong>Efficiency:</strong> Greedy schedule dominated by O(N log N); routing O((V+E) log V); DP cost O(H).</p>
      <pre><code class="language-cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Task{int id;string name;int duration,deadline;double penalty;};
bool taskCmp(const Task&a,const Task&b){
  if(a.deadline!=b.deadline)return a.deadline&lt;b.deadline;
  return a.penalty&gt;b.penalty;
}
struct LEdge{int to;double cost;};
using LGraph=vector&lt;vector&lt;LEdge&gt;&gt;;
vector&lt;double&gt; shortestPathL(const LGraph &g,int src){
  int n=g.size();const double INF=1e18;
  vector&lt;double&gt; dist(n,INF);dist[src]=0;
  using P=pair&lt;double,int&gt;;
  priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt;&gt; pq;
  pq.push({0,src});
  while(!pq.empty()){
    auto [d,u]=pq.top();pq.pop();
    if(d&gt;dist[u])continue;
    for(auto &e:g[u]){
      if(dist[u]+e.cost&lt;dist[e.to]){
        dist[e.to]=dist[u]+e.cost;pq.push({dist[e.to],e.to});
      }
    }
  }
  return dist;
}
map&lt;pair&lt;int,int&gt;,double&gt; memoConstr;
double projectCostDP(int pid,int day,int H,double base,double risk){
  if(day&gt;=H)return 0;
  auto key=make_pair(pid,day);
  if(memoConstr.count(key))return memoConstr[key];
  return memoConstr[key]=base*(1.0+risk*day)+projectCostDP(pid,day+1,H,base,risk);
}
int main(){
  vector&lt;Task&gt; tasks={{1,"Foundations",30,60,5000},
                       {2,"Piers",40,120,4000},
                       {3,"Deck",50,180,6000}};
  sort(tasks.begin(),tasks.end(),taskCmp);
  int cur=0;double totalPen=0;
  for(auto&t:tasks){
    int finish=cur+t.duration;
    int delay=max(0,finish-t.deadline);
    double pen=delay*t.penalty;totalPen+=pen;
    cout &lt;&lt; "Task " &lt;&lt; t.id &lt;&lt; " delay=" &lt;&lt; delay &lt;&lt; " pen=" &lt;&lt; pen &lt;&lt; "\n";
    cur=finish;
  }
  cout &lt;&lt; "Total penalty: " &lt;&lt; totalPen &lt;&lt; "\n";
  LGraph g(3); g[0].push_back({1,10.0}); g[0].push_back({2,20.0});
  auto d=shortestPathL(g,0);
  cout &lt;&lt; "Depot->Site1: " &lt;&lt; d[1] &lt;&lt; "\n";
  cout &lt;&lt; "10-day project cost: " &lt;&lt; projectCostDP(1,0,10,100000,0.02) &lt;&lt; "\n";
  return 0;
}
      </code></pre>
    </section>
  </div>

  <footer>
    Coastal Smart City – Four Algorithmic Business Models (Single Page View)
  </footer>
</div>

<script>
  const navLinks = document.querySelectorAll('.navbar a[data-business]');
  const views = {
    fuel: document.getElementById('view-fuel'),
    apmc: document.getElementById('view-apmc'),
    traffic: document.getElementById('view-traffic'),
    construction: document.getElementById('view-construction')
  };

  function showBusiness(name){
    Object.keys(views).forEach(k=>{
      if(k===name) views[k].classList.remove('hidden');
      else views[k].classList.add('hidden');
    });
    navLinks.forEach(a=>{
      if(a.dataset.business===name) a.classList.add('active');
      else a.classList.remove('active');
    });
  }

  navLinks.forEach(a=>{
    a.addEventListener('click',e=>{
      e.preventDefault();
      showBusiness(a.dataset.business);
    });
  });

  showBusiness('fuel');
</script>
</body>
</html>
